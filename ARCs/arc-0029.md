---
arc: 29
title: Interface detection
description: Specification to identify interfaces of applications
author: St√©phane Barroso (@sudoweezy)
discussions-to: https://github.com/algorandfoundation/ARCs/issues/166
status: Draft
type: Standards Track
category: Interface
created: 2023-01-30
require: 23
---

## Abstract

The following document introduces an extension of [ARC-23](arc-0023.md).

The goal of this convention is to standardize the process to identify interfaces of applications, by appending interface's ARC to the compiled application's bytes. 

## Specification

The key words "**MUST**", "**MUST NOT**", "**REQUIRED**", "**SHALL**", "**SHALL NOT**", "**SHOULD**", "**SHOULD NOT**", "**RECOMMENDED**", "**MAY**", and "**OPTIONAL**" in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119</a>.

> Comments like this are non-normative.

### String containing Application's Interfaces
An application's interface is represented by an ARC number.

The string represents and array of Application's Interfaces that:

* **MUST** starts with a string  `arc29` 

* **MUST** contains ARC's number separated 


> eg: if an application follow interfaces from ARCs XX & YY & ZZ, the corresponding string will be `arc29 XX YY ZZ `

### Associated Encoded Information Byte String

The (encoded) information byte string is the array of the previous section.

The information byte string always starts, in hexadecimal with `0x6172633239` (corresponding to `arcs29`).

> Example: for the following `arcs29 1 20 300`, the list of interfaces to the following hexadecimal value: 
>
> ```
> 0x6172633239 0x01 0x14 0x012c
> ```

### Inclusion of the Encoded Information Byte String in Programs

The encoded information byte string is included in the *approval program* of the application via a <a href="https://developer.algorand.org/docs/get-details/dapps/avm/teal/opcodes/#bytecblock-bytes">`bytecblock`</a> with a unique byte string equal to the encoding information byte string.

> For the example above, the `bytecblock` is:
>
> ```
> bytecblock 0x6172633239 0x01 0x14 0x012c
> ```
>
The size of the compiled application plus the bytecblock **MUST** be, at most, the maximum size of a compiled application according to the latest consensus parameters supported by the compiler.

> At least with TEAL v8 and before, appending the previous `bytecblock` to the end of the program should add exactly 17 bytes:
>   1 byte for 0x26 opcode `bytecblock`
>   1 byte for 0x04 -the number of byte strings-
>   1 byte for 0x05 the length of the encoded information 1st byte string
>   5 byte for 0x6172633239 the `arc29`
>   1 byte for 0x01 the length of the encoded information 2nd byte string
>   1 byte for 0x01 the `1`
>   1 byte for 0x02 the length of the encoded information 3rd byte string
>   2 byte for 0x14 the `20`
>   1 byte for 0x03 the length of the encoded information 4th byte string
>   3 byte for 0x012c the `300`

The `bytecblock` **MAY** be placed anywhere in the TEAL source code as long as it does not modify the semantic of the TEAL source code.
The `bytecblock` **SHOULD** be the last opcode of the deployed TEAL program.

Developers **MUST** check that, when adding the `bytecblock` to their program, semantic is not changed.

### Retrieval the Encoded Information Byte String and CID from Compiled TEAL Programs

For programs until TEAL v8, a way to find the encoded information byte string is to search for the prefix:

```
6172633239
```
Indeed, this prefix is composed of:
* 0x6172633239, the hexadecimal of `arc29`

Software retrieving the encoded information byte string **SHOULD** check the TEAL version and only perform retrieval for supported TEAL version.
They also **SHOULD** gracefully handle false positives, that is when the above prefix is found multiple times.


Note that opcode encoding may change with the TEAL version (though this did not happen up to TEAL v8 at least).
If the `bytecblock` opcode encoding changes, software that extract the encoded information byte string from compiled TEAL programs **MUST** be updated.

## Rationale

By appending the interfaces standards of an Application, any user with access to the blockchain could interact with an application without having to check the ABI.

## Reference Implementation

The following codes are not audited and are only here for information purposes.

Here is an example of a python script that can generate the hash and append it to the compiled application, according this ARC:
[main.py](../assets/arc-0029/main.py).

## Security Considerations
An `arc-29 added at the end of an application is here to share information, not proof of anything.
Interfaces are only here to help users to interact with the application. 
It is the users reponsability to ensure that the application conforms. 

## Copyright

Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.