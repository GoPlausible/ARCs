---
arc: <to be assigned>
title: Application Specification
description: A specification for fully describing an Application, useful for Application clients.
author: Benjamin Guidarelli (@barnjamin), ...
discussions-to: <URL>
status: Draft
type: Standards Track
category: ARC
created: 2022-12-01
requires (*optional): ARC-0004, ARC-0021 
---

## Abstract

An Application is partially defined by it's [methods](arc-0004.md) but further information about the Application should be available.  Other descriptive elements of an application may include it's State Schema, the original TEAL source programs, default method arguments, and custom data types.  This specification defines the descriptive elements of an Application that should be available to clients to provide useful information for an Application Client.

## Motivation

As more complex Applications are created and deployed, some consistent way to specify the details is important. A specification to allow a consistent and complete definition of an application will help developers attempting to integrate an application they've never worked with before. 

 
 WIP....

Currently applications don't provide info about things like:
- state schema
- default args
- errors
- user defined types/structs
- extra fees required

This leads to a more difficult experience when a developer wishes to begin using an application. 

Given this information in a structured way, a client, written in any langue, should be able to infer or directly read certain things that  issues when 


## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc822.txt">RFC 822</a>..


### Definitions

- [Application Specification](#application-specification): The object containing the elements describing the Application.
- [Source Specification](#source-specification): The object containing a description of the TEAL source programs that are evaluated when this Application is called.
- [Schema Specification](#schema-specification): The object containing a description of the schema required by the Application.
- [Type Specification](#type-specification): The object containing a map type name of name to the user defined data types (TODO: only structs for now as NamedTuples, allow other aliases like `type hash = byte[32]` or something?) 
- [Error Specification](#error-specification): The object containing a map of `pc` to Error message



### Application Specification


The Application Specification is composed of a number of elements that serve to fully describe the 

```ts
type AppSpec = {
  // embedded contract fields, see ARC-0004 for more
  algosdk.ABIContract;
  // the original teal source, base64 encoded, containing annotations 
  source?: SourceSpec;
  // the schema this application requires along with
  // details about the fields
  schema?: SchemaSpec;
  // user defined types
  types?: TypeSpec;
  // map of pc=>error message
  errors?: ErrorSpec;
}
```
### Source Specification

Contains the source TEAL files including comments and other annotations.

```ts
// Opject containing the original TEAL source files
type SourceSpec = {
  // b64 encoded approval program
  approval: string;
  // b64 encoded clear state program
  clear: string;
}
```

### Schema Specification

The schema of an application is critical to know prior to creation since it is immutable after create. It also helps clients of the application understand the data that is available to be queried from off chain. Individual fields can be referenced from the [default arguments](#default-arguments) to provide input data to a given ABI method.

While some fields are possible to know ahead of time, others may be keyed dynamically. In both cases the data type being stored MUST be known and declared ahead of time. 

TODO: describe diff between Declared/Reserved and motivation for providing both

TODO: describe how to decode the type and the value given the decoded type



```ts
// The complete schema for this application
type SchemaSpec = {
  local: Schema;
  global: Schema;
}

// Schema fields may be declared explicitly or reserved
type Schema = {
  declared: Record<string, DeclaredSchemaValueSpec>;
  reserved: Record<string, ReservedSchemaValueSpec>;
}

// Types supported for encoding/decoding
enum AVMType { uint64, bytes }
type ABIType = string;

// Fields that have an explicit key
type DeclaredSchemaValueSpec = {
  type: AVMType | ABIType;
  key: string;
  desc: string;
}

// Fields that have an undetermined key
type ReservedSchemaValueSpec = {
  type: AVMType | ABIType;
  desc: string;
  max_keys: number;
}

```

### Type Specification

Each user defined type is treated as a named tuple of fields. The ABI encoding is exactly as if the struct had its fields specified in the same order as a tuple with the same containing fields. 

It is important to encode the struct elements as an array since it preserves the order of fields which is critical to encoding/decoding the data properly.

```ts
// Each field in the struct contains a name and ABI type
type StructElement = [string, string];
// A map of type name to list of struct fields
type TypeSpec = Record<string, StructElement[]>
```

ex: A PyTeal `abi.NamedTuple` defined as
```py
from pyteal import abi

class Thing(abi.NamedTuple):
  addr: abi.Field[abi.address]
  balance: abi.Field[abi.Uint64]
```
should have an element in the type spec of:

```js
{
// ...
"thing":[["addr", "address"]["balance","uint64"]],
// ...
}
```




### Error Specification

The Error specification contains a mapping of `PC` (or `Program counter`) to a human readable string that describes the error condition. 

```ts
// TODO: more complex spec for errors? what else would we want? 
type ErrorMsg = string;

type ErrorSpec = Record<number, ErrorMsg>;
```

To build an error spec, compile the source teal program with its source map, and map the `PC` of any `assert` or `err` opcodes with a comment on the immediately preceeding line into the `ErrorSpec` map. 

TODO: number as key will fail in certain places, lets do something else?
ex: the following will produce an entry in the error spec like `{..., 10: "// Sorry but 2 is not less than 1", ...}` assuming the `PC` of the `assert` op is 10.
```
int 1    
int 2
<
// Sorry but 2 is not less than 1
assert
```

### Default Argument

TODO: this should probable be proposed in a separate ARC like the `read-only` attr?
```ts

type DefaultArgumentSource = "global-state" | "local-state" | "abi-method" | "constant";
export type DefaultArgument = {
  // Where to look for the default arg value 
  source: DefaultArgumentSource;
  // extra data to include when looking up the value (key for state, actual data for constant)
  data: string | bigint | number;
}

```

## Rationale
The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work, e.g. how the feature is supported in other languages.

## Backwards Compatibility
All ARCs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The ARC must explain how the author proposes to deal with these incompatibilities. ARC submissions without a sufficient backwards compatibility treatise may be rejected outright.

## Test Cases
Test cases for an implementation are mandatory for ARCs that are affecting consensus changes.  If the test suite is too large to reasonably be included inline, then consider adding it as one or more files in `../assets/arc-####/`.

## Reference Implementation
An optional section that contains a reference/example implementation that people can use to assist in understanding or implementing this specification.  If the implementation is too large to reasonably be included inline, then consider adding it as one or more files in `../assets/arc-####/`.

## Security Considerations
All ARCs must contain a section that discusses the security implications/considerations relevant to the proposed change. Include information that might be important for security discussions, surfaces risks and can be used throughout the life cycle of the proposal. E.g. include security-relevant design decisions, concerns, important discussions, implementation-specific guidance and pitfalls, an outline of threats and risks and how they are being addressed. ARC submissions missing the "Security Considerations" section will be rejected. An ARC cannot proceed to status "Final" without a Security Considerations discussion deemed sufficient by the reviewers.

## Copyright
Copyright and related rights waived via <a href="https://creativecommons.org/publicdomain/zero/1.0/">CCO</a>.
